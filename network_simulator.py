# -*- coding: utf-8 -*-
"""Network Simulator Core

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18Olql60uGM3kJzOQfbsPmICXfHf_c4zo
"""

import heapq
import matplotlib.pyplot as plt
import networkx as nx
import time

class Router:
    """
    Represents a router in the network.
    Each router has a name and maintains a routing table.
    """
    def __init__(self, name):
        self.name = name
        # The routing table will store the shortest path to other routers.
        # Format: {destination: (next_hop, cost)}
        self.routing_table = {self.name: (self.name, 0)}

    def __repr__(self):
        return f"Router({self.name})"

class Network:
    """
    Represents the entire network, containing routers and links.
    It manages the network topology and runs routing algorithms.
    """
    def __init__(self):
        # Adjacency list to represent the network graph.
        # Format: {router: {neighbor: cost}}
        self.adjacency_list = {}
        self.routers = {}

    def add_router(self, name):
        """Adds a router to the network."""
        if name not in self.routers:
            router = Router(name)
            self.routers[name] = router
            self.adjacency_list[name] = {}
            print(f"INFO: Router {name} added.")
            return True
        else:
            print(f"WARNING: Router {name} already exists.")
            return False

    def remove_router(self, router_name):
        """Removes a router and all its associated links from the network."""
        if router_name in self.routers:
            del self.routers[router_name]
            del self.adjacency_list[router_name]

            # Remove any links pointing to this router from other routers
            for r_name in list(self.adjacency_list.keys()):
                if router_name in self.adjacency_list[r_name]:
                    del self.adjacency_list[r_name][router_name]

            print(f"INFO: Router {router_name} and its links have been removed.")
            return True
        else:
            print(f"WARNING: Router {router_name} not found.")
            return False

    def add_link(self, router1_name, router2_name, cost):
        """Adds a bidirectional link between two routers with a given cost."""
        if router1_name in self.routers and router2_name in self.routers:
            if cost < 0:
                print(f"WARNING: Negative cost ({cost}) added for link {router1_name}-{router2_name}. Dijkstra's algorithm will not work correctly.")
            self.adjacency_list[router1_name][router2_name] = cost
            self.adjacency_list[router2_name][router1_name] = cost
            print(f"INFO: Link added between {router1_name} and {router2_name} with cost {cost}.")
            return True
        else:
            print(f"ERROR: One or both routers not found for link {router1_name}-{router2_name}.")
            return False

    def remove_link(self, router1_name, router2_name):
        """Removes a bidirectional link between two routers."""
        if router1_name in self.adjacency_list and router2_name in self.adjacency_list.get(router1_name, {}):
            del self.adjacency_list[router1_name][router2_name]
            if router2_name in self.adjacency_list:
                del self.adjacency_list[router2_name][router1_name]
            print(f"INFO: Link removed between {router1_name} and {router2_name}.")
            return True
        else:
            print(f"WARNING: Link between {router1_name} and {router2_name} not found.")
            return False

    def dijkstra(self, start_router_name):
        """
        Calculates the shortest path from a starting router to all other routers
        using Dijkstra's algorithm. Assumes non-negative edge weights.
        """
        if start_router_name not in self.routers:
            print(f"ERROR: Router {start_router_name} not found.")
            return {}

        pq = [(0, start_router_name, [])]
        min_costs = {router: float('inf') for router in self.routers}
        min_costs[start_router_name] = 0
        shortest_paths = {router: [] for router in self.routers}

        router = self.routers[start_router_name]
        router.routing_table = {r: (None, float('inf')) for r in self.routers}
        router.routing_table[start_router_name] = (start_router_name, 0)

        while pq:
            cost, current_router_name, path = heapq.heappop(pq)

            if cost > min_costs[current_router_name]:
                continue

            path = path + [current_router_name]
            shortest_paths[current_router_name] = path

            if len(path) > 1:
                next_hop = path[1]
            else:
                next_hop = start_router_name
            router.routing_table[current_router_name] = (next_hop, cost)

            for neighbor, weight in self.adjacency_list[current_router_name].items():
                new_cost = cost + weight
                if new_cost < min_costs[neighbor]:
                    min_costs[neighbor] = new_cost
                    heapq.heappush(pq, (new_cost, neighbor, path))

        return shortest_paths

    def bellman_ford(self, start_router_name):
        """
        Calculates the shortest path from a starting router to all other routers
        using the Bellman-Ford algorithm. Can handle negative edge weights.
        """
        if start_router_name not in self.routers:
            print(f"ERROR: Router {start_router_name} not found.")
            return {}

        min_costs = {router: float('inf') for router in self.routers}
        min_costs[start_router_name] = 0
        predecessors = {router: None for router in self.routers}

        router = self.routers[start_router_name]
        router.routing_table = {r: (None, float('inf')) for r in self.routers}
        router.routing_table[start_router_name] = (start_router_name, 0)

        edges = []
        for u, neighbors in self.adjacency_list.items():
            for v, weight in neighbors.items():
                edges.append((u, v, weight))

        num_routers = len(self.routers)
        for _ in range(num_routers - 1):
            for u, v, weight in edges:
                if min_costs[u] != float('inf') and min_costs[u] + weight < min_costs[v]:
                    min_costs[v] = min_costs[u] + weight
                    predecessors[v] = u

        # Check for negative weight cycles
        for u, v, weight in edges:
            if min_costs[u] != float('inf') and min_costs[u] + weight < min_costs[v]:
                print("ERROR: Negative weight cycle detected. Bellman-Ford cannot proceed.")
                return None

        # Reconstruct paths and update routing table
        shortest_paths = {}
        for dest_name in self.routers:
            if min_costs[dest_name] != float('inf'):
                path = []
                current = dest_name
                while current is not None:
                    path.insert(0, current)
                    current = predecessors[current]
                shortest_paths[dest_name] = path

                next_hop = path[1] if len(path) > 1 else dest_name
                router.routing_table[dest_name] = (next_hop, min_costs[dest_name])

        return shortest_paths

    def update_all_routing_tables(self, algorithm='dijkstra'):
        """Convenience method to run the selected update algorithm."""
        if algorithm == 'dijkstra':
            self.update_all_routing_tables_dijkstra()
        elif algorithm == 'bellman_ford':
            self.update_all_routing_tables_bellman_ford()
        else:
            print(f"ERROR: Unknown algorithm '{algorithm}'.")

    def update_all_routing_tables_dijkstra(self):
        """Updates the routing tables for all routers in the network using Dijkstra."""
        print("\n--- Updating all routing tables using Dijkstra's Algorithm ---")
        start_time = time.time()
        for router_name in self.routers:
            self.dijkstra(router_name)
        end_time = time.time()
        print(f"Dijkstra update took: {end_time - start_time:.6f} seconds.")
        print("--- All routing tables updated. ---\n")

    def update_all_routing_tables_bellman_ford(self):
        """Updates the routing tables for all routers in the network using Bellman-Ford."""
        print("\n--- Updating all routing tables using Bellman-Ford Algorithm ---")
        start_time = time.time()
        for router_name in self.routers:
            if self.bellman_ford(router_name) is None:
                print(f"Update failed for router {router_name} due to negative cycle.")
                break # Stop if a negative cycle is found
        end_time = time.time()
        print(f"Bellman-Ford update took: {end_time - start_time:.6f} seconds.")
        print("--- All routing tables updated. ---\n")

    def get_routing_tables_str(self):
        """Returns the routing tables as a formatted string."""
        output = ""
        for router_name, router in self.routers.items():
            output += f"Router: {router.name}\n"
            output += "Destination | Next Hop | Cost\n"
            output += "---------------------------------\n"
            sorted_table = sorted(router.routing_table.items())
            for dest, (next_hop, cost) in sorted_table:
                cost_str = str(cost) if cost != float('inf') else "inf"
                next_hop_str = str(next_hop) if next_hop is not None else "N/A"
                output += f"{dest: <12}| {next_hop_str: <9}| {cost_str}\n"
            output += "\n"
        return output

    def visualize_network(self, ax, shortest_path=None):
        """
        Visualizes the network graph on a given matplotlib Axes object.
        """
        ax.clear()
        G = nx.Graph()
        if not self.routers:
            ax.text(0.5, 0.5, "Network is empty. Add routers and links.", ha='center', va='center')
            ax.set_title("Network Topology")
            return

        for router_name in self.routers:
            G.add_node(router_name)

        edge_labels = {}
        for router1, neighbors in self.adjacency_list.items():
            for router2, cost in neighbors.items():
                if not G.has_edge(router1, router2):
                    G.add_edge(router1, router2, weight=cost)
                    edge_labels[(router1, router2)] = cost

        pos = nx.spring_layout(G, seed=42)
        nx.draw(G, pos, ax=ax, with_labels=True, node_color='skyblue', node_size=1500,
                edge_color='gray', width=1.5, font_size=12)
        nx.draw_networkx_edge_labels(G, pos, ax=ax, edge_labels=edge_labels, font_color='red')

        if shortest_path:
            path_edges = list(zip(shortest_path, shortest_path[1:]))
            nx.draw_networkx_nodes(G, pos, ax=ax, nodelist=shortest_path, node_color='lightgreen', node_size=1500)
            nx.draw_networkx_edges(G, pos, ax=ax, edgelist=path_edges, edge_color='green', width=3)
            ax.set_title("Network Topology with Shortest Path", size=16)
        else:
            # This line is now correctly indented.
            ax.set_title("Network Topology", size=16)

def build_common_topology():
    """Helper function to create a standard network for simulations."""
    network = Network()
    routers_to_add = ['A', 'B', 'C', 'D', 'E', 'F']
    for r in routers_to_add:
        network.add_router(r)
    network.add_link('A', 'B', 4)
    network.add_link('A', 'C', 2)
    network.add_link('B', 'C', 1)
    network.add_link('B', 'D', 5)
    network.add_link('C', 'D', 8)
    network.add_link('C', 'E', 10)
    network.add_link('D', 'E', 2)
    network.add_link('D', 'F', 6)
    network.add_link('E', 'F', 3)
    return network

# The __main__ block is for command-line execution and is not used by the GUI.
if __name__ == '__main__':
    # This block is for testing the network logic independently.
    # You can uncomment it to run tests without the GUI.

    # print("--- DIJKSTRA SIMULATION ---")
    # net_dijkstra = build_common_topology()
    # net_dijkstra.update_all_routing_tables_dijkstra()
    # print(net_dijkstra.get_routing_tables_str())
    # shortest_paths_d = net_dijkstra.dijkstra('A')
    # print(f"Shortest path from A to F: {shortest_paths_d.get('F', 'Not found')}")

    # # Simulate a link failure
    # print("\n--- Simulating Link Failure (B-C) ---")
    # net_dijkstra.remove_link('B', 'C')
    # net_dijkstra.update_all_routing_tables_dijkstra()
    # shortest_paths_d_after_fail = net_dijkstra.dijkstra('A')
    # print(f"New shortest path from A to F: {shortest_paths_d_after_fail.get('F', 'Not found')}")

    # print("\n\n--- BELLMAN-FORD SIMULATION ---")
    # net_bf = build_common_topology()
    # # Example with a negative edge
    # # net_bf.add_link('D', 'A', -1) # Uncomment to test negative weights
    # net_bf.update_all_routing_tables_bellman_ford()
    # print(net_bf.get_routing_tables_str())
    # shortest_paths_bf = net_bf.bellman_ford('A')
    # print(f"Shortest path from A to F: {shortest_paths_bf.get('F', 'Not found')}")

    pass